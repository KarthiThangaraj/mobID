/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input } from '@angular/core';
var ProgressBarComponent = /** @class */ (function () {
    function ProgressBarComponent() {
        // Default color
        this.color = "#488aff";
    }
    /**
     * Returns a color for a certain percent
     * @param percent The current progress
     */
    /**
     * Returns a color for a certain percent
     * @param {?} percent The current progress
     * @return {?}
     */
    ProgressBarComponent.prototype.whichColor = /**
     * Returns a color for a certain percent
     * @param {?} percent The current progress
     * @return {?}
     */
    function (percent) {
        var e_1, _a;
        // Get all entries index as an array
        /** @type {?} */
        var k = Object.keys(this.degraded);
        // Convert string to number
        k.forEach(function (e, i) { return k[i] = +e; });
        // Sort them by value
        k = k.sort(function (a, b) { return a - b; });
        // Percent as number
        /** @type {?} */
        var p = +percent
        // Set last by default as the first occurrence
        ;
        // Set last by default as the first occurrence
        /** @type {?} */
        var last = k[0];
        try {
            // Foreach keys 
            for (var k_1 = tslib_1.__values(k), k_1_1 = k_1.next(); !k_1_1.done; k_1_1 = k_1.next()) {
                var val = k_1_1.value;
                // if current val is < than percent
                if (val < p) {
                    last = val;
                }
                // if val >= percent then the val that we could show has been reached
                else if (val >= p - 1) {
                    return this.degraded[last];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (k_1_1 && !k_1_1.done && (_a = k_1.return)) _a.call(k_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // if its the last one return the last
        return this.degraded[last];
    };
    /**
     * @param {?} progress
     * @return {?}
     */
    ProgressBarComponent.prototype.whichProgress = /**
     * @param {?} progress
     * @return {?}
     */
    function (progress) {
        try {
            return Math.round(+progress * 100) / 100;
        }
        catch (_a) {
            return progress;
        }
    };
    ProgressBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'progress-bar',
                    template: "\n  <div class=\"progress-outer\">\n    <div class=\"progress-inner\" [style.width]=\"whichProgress(progress) + '%'\" [style.background-color]=\"degraded == null ? color : whichColor(progress)\">\n      {{whichProgress(progress)}}%\n    </div>\n  </div>\n  ",
                    styles: ["\n        .progress-outer {\n          width: 96%;\n          margin: 10px 2%;\n          padding: 3px;\n          background-color: #f4f4f4;\n          border: 1px solid #dcdcdc;\n          color: #fff;\n          border-radius: 20px;\n          text-align: center;\n        }\n        .progress-inner {\n          min-width: 15%;\n          white-space: nowrap;\n          overflow: hidden;\n          padding: 0px;\n          border-radius: 20px;\n  "]
                }] }
    ];
    /** @nocollapse */
    ProgressBarComponent.ctorParameters = function () { return []; };
    ProgressBarComponent.propDecorators = {
        progress: [{ type: Input, args: ['progress',] }],
        color: [{ type: Input, args: ['color',] }],
        degraded: [{ type: Input, args: ['color-degraded',] }]
    };
    return ProgressBarComponent;
}());
export { ProgressBarComponent };
if (false) {
    /**
     * Inputs *
     * @type {?}
     */
    ProgressBarComponent.prototype.progress;
    /** @type {?} */
    ProgressBarComponent.prototype.color;
    /** @type {?} */
    ProgressBarComponent.prototype.degraded;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1wcm9ncmVzcy1iYXIvIiwic291cmNlcyI6WyJsaWIvYW5ndWxhci1wcm9ncmVzcy1iYXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFakQ7SUFzQ0E7UUFDRSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0gseUNBQVU7Ozs7O0lBQVYsVUFBVyxPQUFlOzs7O1lBRXBCLENBQUMsR0FBZSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDOUMsMkJBQTJCO1FBQzNCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFULENBQVMsQ0FBQyxDQUFDO1FBQy9CLHFCQUFxQjtRQUNyQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDLElBQUssT0FBQSxDQUFDLEdBQUcsQ0FBQyxFQUFMLENBQUssQ0FBQyxDQUFDOzs7WUFFeEIsQ0FBQyxHQUFHLENBQUMsT0FBTztRQUNoQiw4Q0FBOEM7Ozs7WUFDMUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7O1lBQ2YsZ0JBQWdCO1lBQ2hCLEtBQWUsSUFBQSxNQUFBLGlCQUFBLENBQUMsQ0FBQSxvQkFBQSxtQ0FBQztnQkFBYixJQUFJLEdBQUcsY0FBQTtnQkFDVCxtQ0FBbUM7Z0JBQ25DLElBQUcsR0FBRyxHQUFHLENBQUMsRUFBQztvQkFDVCxJQUFJLEdBQUcsR0FBRyxDQUFDO2lCQUNaO2dCQUNELHFFQUFxRTtxQkFDaEUsSUFBRyxHQUFHLElBQUksQ0FBQyxHQUFFLENBQUMsRUFBQztvQkFDbEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUM1QjthQUNGOzs7Ozs7Ozs7UUFDRCxzQ0FBc0M7UUFDdEMsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBRUQsNENBQWE7Ozs7SUFBYixVQUFjLFFBQWdCO1FBQzVCLElBQUc7WUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1NBQzFDO1FBQ0QsV0FBSztZQUNILE9BQU8sUUFBUSxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQzs7Z0JBaEZBLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQ0osY0FBYztvQkFtQmxCLFFBQVEsRUFDUixtUUFNQzs2QkF6QlEsdWNBaUJSO2lCQVNGOzs7OzsyQkFJRSxLQUFLLFNBQUMsVUFBVTt3QkFDaEIsS0FBSyxTQUFDLE9BQU87MkJBQ2IsS0FBSyxTQUFDLGdCQUFnQjs7SUE4Q3pCLDJCQUFDO0NBQUEsQUFqRkQsSUFpRkM7U0FuRFksb0JBQW9COzs7Ozs7SUFHL0Isd0NBQW9DOztJQUNwQyxxQ0FBOEI7O0lBQzlCLHdDQUF1QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOlxyXG4gICAgICAncHJvZ3Jlc3MtYmFyJyxcclxuICBzdHlsZXM6IFtgXHJcbiAgICAgICAgLnByb2dyZXNzLW91dGVyIHtcclxuICAgICAgICAgIHdpZHRoOiA5NiU7XHJcbiAgICAgICAgICBtYXJnaW46IDEwcHggMiU7XHJcbiAgICAgICAgICBwYWRkaW5nOiAzcHg7XHJcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0O1xyXG4gICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgI2RjZGNkYztcclxuICAgICAgICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMjBweDtcclxuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLnByb2dyZXNzLWlubmVyIHtcclxuICAgICAgICAgIG1pbi13aWR0aDogMTUlO1xyXG4gICAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICAgICAgICBwYWRkaW5nOiAwcHg7XHJcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xyXG4gIGBdLFxyXG4gIHRlbXBsYXRlOlxyXG4gIGBcclxuICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1vdXRlclxcXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1pbm5lclxcXCIgW3N0eWxlLndpZHRoXT1cXFwid2hpY2hQcm9ncmVzcyhwcm9ncmVzcykgKyAnJSdcXFwiIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cXFwiZGVncmFkZWQgPT0gbnVsbCA/IGNvbG9yIDogd2hpY2hDb2xvcihwcm9ncmVzcylcXFwiPlxyXG4gICAgICB7e3doaWNoUHJvZ3Jlc3MocHJvZ3Jlc3MpfX0lXHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuICBgXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQcm9ncmVzc0JhckNvbXBvbmVudCB7XHJcblxyXG4vKiogSW5wdXRzICoqL1xyXG4gIEBJbnB1dCgncHJvZ3Jlc3MnKSBwcm9ncmVzczogc3RyaW5nO1xyXG4gIEBJbnB1dCgnY29sb3InKSBjb2xvcjogc3RyaW5nO1xyXG4gIEBJbnB1dCgnY29sb3ItZGVncmFkZWQnKSBkZWdyYWRlZDogYW55O1xyXG5cclxuXHJcbmNvbnN0cnVjdG9yKCkge1xyXG4gIC8vIERlZmF1bHQgY29sb3JcclxuICB0aGlzLmNvbG9yID0gXCIjNDg4YWZmXCI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29sb3IgZm9yIGEgY2VydGFpbiBwZXJjZW50XHJcbiAqIEBwYXJhbSBwZXJjZW50IFRoZSBjdXJyZW50IHByb2dyZXNzXHJcbiAqL1xyXG53aGljaENvbG9yKHBlcmNlbnQ6IHN0cmluZyl7XHJcbiAgLy8gR2V0IGFsbCBlbnRyaWVzIGluZGV4IGFzIGFuIGFycmF5XHJcbiAgbGV0IGs6IEFycmF5PGFueT4gPSBPYmplY3Qua2V5cyh0aGlzLmRlZ3JhZGVkKTtcclxuICAvLyBDb252ZXJ0IHN0cmluZyB0byBudW1iZXJcclxuICBrLmZvckVhY2goKGUsIGkpID0+IGtbaV0gPSArZSk7XHJcbiAgLy8gU29ydCB0aGVtIGJ5IHZhbHVlXHJcbiAgayA9IGsuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG4gIC8vIFBlcmNlbnQgYXMgbnVtYmVyXHJcbiAgbGV0IHAgPSArcGVyY2VudFxyXG4gIC8vIFNldCBsYXN0IGJ5IGRlZmF1bHQgYXMgdGhlIGZpcnN0IG9jY3VycmVuY2VcclxuICBsZXQgbGFzdCA9IGtbMF07XHJcbiAgLy8gRm9yZWFjaCBrZXlzIFxyXG4gIGZvcihsZXQgdmFsIG9mIGspe1xyXG4gICAgLy8gaWYgY3VycmVudCB2YWwgaXMgPCB0aGFuIHBlcmNlbnRcclxuICAgIGlmKHZhbCA8IHApe1xyXG4gICAgICBsYXN0ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgdmFsID49IHBlcmNlbnQgdGhlbiB0aGUgdmFsIHRoYXQgd2UgY291bGQgc2hvdyBoYXMgYmVlbiByZWFjaGVkXHJcbiAgICBlbHNlIGlmKHZhbCA+PSBwIC0xKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVncmFkZWRbbGFzdF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIGlmIGl0cyB0aGUgbGFzdCBvbmUgcmV0dXJuIHRoZSBsYXN0XHJcbiAgcmV0dXJuIHRoaXMuZGVncmFkZWRbbGFzdF07XHJcbn1cclxuXHJcbndoaWNoUHJvZ3Jlc3MocHJvZ3Jlc3M6IHN0cmluZyl7XHJcbiAgdHJ5e1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoK3Byb2dyZXNzICogMTAwKSAvIDEwMDtcclxuICB9XHJcbiAgY2F0Y2h7XHJcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XHJcbiAgfVxyXG59XHJcbn0iXX0=